type Address = record {
  street : text;
  country : text;
  city : text;
  postal_code : text;
  label : text;
  state_or_province : text;
  house_number : text;
  house_number_addition : text;
};
type ApiError = variant {
  SerializeError : ErrorMessage;
  DeserializeError : ErrorMessage;
  NotFound : ErrorMessage;
  ValidationError : vec ValidationResponse;
  CanisterAtCapacity : ErrorMessage;
  UpdateRequired : UpdateMessage;
  Unauthorized : ErrorMessage;
  Unexpected : ErrorMessage;
  BadRequest : ErrorMessage;
};
type Asset = variant { Url : text; None; CanisterStorage : CanisterStorage };
type CanisterStorage = variant { None; Manifest : Manifest; Chunk : ChunkData };
type CanisterType = variant {
  Empty;
  Foundation;
  Custom;
  ScalableChild;
  Scalable;
};
type ChunkData = record {
  chunk_id : nat64;
  canister : principal;
  index : nat64;
};
type DateRange = record { end_date : nat64; start_date : nat64 };
type ErrorMessage = record {
  tag : text;
  message : text;
  inputs : opt vec text;
  location : text;
};
type FilterType = variant { Or; And };
type Gated = record {
  "principal" : principal;
  name : text;
  description : text;
  amount : nat64;
  standard : text;
};
type GroupFilter = variant {
  Tag : nat32;
  UpdatedOn : DateRange;
  MemberCount : record { nat64; nat64 };
  Name : text;
  Identifiers : vec principal;
  Owner : principal;
  CreatedOn : DateRange;
};
type GroupResponse = record {
  updated_on : nat64;
  banner_image : Asset;
  owner : principal;
  name : text;
  matrix_space_id : text;
  tags : vec nat32;
  description : text;
  created_by : principal;
  created_on : nat64;
  website : text;
  privacy : Privacy;
  image : Asset;
  identifier : principal;
  member_count : nat64;
  location : Location;
  roles : vec GroupRole;
  is_deleted : bool;
};
type GroupRole = record {
  permissions : vec Permission;
  name : text;
  color : text;
  protected : bool;
  index : opt nat64;
};
type HttpHeader = record { value : text; name : text };
type HttpRequest = record {
  url : text;
  method : text;
  body : vec nat8;
  headers : vec record { text; text };
};
type HttpResponse = record {
  status : nat;
  body : vec nat8;
  headers : vec HttpHeader;
};
type Location = variant { None; Digital : text; Physical : PhysicalLocation };
type Manifest = record { entries : vec ChunkData };
type PagedResponse = record {
  total : nat64;
  data : vec WhitelistEntry;
  page : nat64;
  limit : nat64;
  number_of_pages : nat64;
};
type Permission = record {
  name : text;
  actions : PermissionActions;
  protected : bool;
};
type PermissionActions = record {
  edit : bool;
  read : bool;
  delete : bool;
  write : bool;
};
type PhysicalLocation = record {
  longtitude : float32;
  address : Address;
  lattitude : float32;
};
type Privacy = variant { Gated : vec Gated; Private; Public; InviteOnly };
type Result = variant { Ok : bool; Err : ApiError };
type Result_1 = variant { Ok : principal; Err : ApiError };
type Result_2 = variant { Ok : ScalableCanisterDetails; Err : text };
type Result_3 = variant { Ok : ScalableMetaData; Err : ApiError };
type Result_4 = variant { Ok : WasmDetails; Err : ApiError };
type Result_5 = variant { Ok : PagedResponse; Err : ApiError };
type Result_6 = variant { Ok : ScalableCanisterDetails; Err : ApiError };
type ScalableCanisterDetails = record {
  entry_range : record { nat64; opt nat64 };
  "principal" : principal;
  wasm_version : WasmVersion;
  is_available : bool;
  canister_type : CanisterType;
};
type ScalableMetaData = record {
  updated_at : nat64;
  canister_count : nat64;
  owner : principal;
  name : text;
  created_at : nat64;
  used_data : nat64;
  cycles : nat64;
  has_child_wasm : bool;
  parent : principal;
};
type UpdateMessage = record { canister_principal : principal; message : text };
type ValidationResponse = record { field : text; message : text };
type WasmDetails = record {
  updated_at : nat64;
  wasm_version : WasmVersion;
  created_at : nat64;
  label : text;
  bytes : vec nat8;
  wasm_type : CanisterType;
};
type WasmVersion = variant { None; Version : nat64; Custom };
type WhitelistEntry = record {
  "principal" : principal;
  rights : WhitelistRights;
  created_on : nat64;
  label : text;
};
type WhitelistRights = variant { Read; ReadWrite; Owner };
service : (text, principal, principal) -> {
  __get_candid_interface_tmp_hack : () -> (text) query;
  accept_cycles : () -> (nat64);
  add_to_whitelist : (text, principal, WhitelistRights) -> (Result);
  add_wasm : (text, vec nat8) -> (Result);
  change_name : (text) -> (bool);
  close_child_canister_and_spawn_sibling : (
      principal,
      nat64,
      vec nat8,
      opt principal,
    ) -> (Result_1);
  get_all_data : (vec GroupFilter, FilterType) -> (vec GroupResponse) query;
  get_available_canister : () -> (Result_2) query;
  get_canisters : () -> (vec ScalableCanisterDetails) query;
  get_latest_wasm_version : () -> (WasmVersion) query;
  get_metadata : () -> (Result_3) query;
  get_wasms : () -> (Result_4) query;
  get_whitelist : (nat64, nat64) -> (Result_5) query;
  http_request : (HttpRequest) -> (HttpResponse) query;
  initialize_first_child_canister : () -> (Result_1);
  reinstall_child_canister : (principal) -> (Result_1);
  remove_from_whitelist : (principal) -> (Result);
  sanity_check : () -> (text) query;
  upgrade_child_canister : (principal) -> (Result_6);
}